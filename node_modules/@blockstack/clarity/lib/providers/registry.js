"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const clarityBin_1 = require("./clarityBin");
class ProviderRegistry {
    constructor() { }
    static registerProvider(providerConstructor, clearExisting = false) {
        if (clearExisting) {
            this.availableProviders.length = 0;
        }
        this.availableProviders.push(providerConstructor);
    }
    /**
     * Attempt loading the default `clarity-native-bin` module. This module must be set as
     * a `peerDependency` and dynamically imported to avoid issues with circular dependencies,
     * and allow consuming libs to specify their own provider.
     * @returns Promise resolves to a `ProviderConstructor` if loaded successfully, or `false`
     * if the module is not available.
     */
    static tryLoadDefaultBinProvider() {
        if (this.defaultLoadCachedPromise) {
            return this.defaultLoadCachedPromise;
        }
        const loadPromise = Promise.resolve((async () => {
            let nativeBinModule;
            try {
                nativeBinModule = await Promise.resolve().then(() => __importStar(require("@blockstack/clarity-native-bin")));
            }
            catch (e) {
                // node.js runtime require error
                if (e.code === "MODULE_NOT_FOUND") {
                    return false;
                }
                // es6 dynamic import errors
                if (e.message) {
                    const importErrStrings = [
                        "error loading dynamically imported module",
                        "error resolving module specifier",
                        "failed to fetch dynamically imported module",
                        "failed to resolve module"
                    ];
                    const errMsg = e.message.toLowerCase();
                    if (importErrStrings.some(errStr => errMsg.includes(errStr))) {
                        return false;
                    }
                }
                throw e;
            }
            const nativeBinFile = nativeBinModule.getDefaultBinaryFilePath();
            const providerConstructor = {
                create: () => clarityBin_1.NativeClarityBinProvider.createEphemeral(nativeBinFile)
            };
            // Reset the cached promise so that future invocations have the chance to retry.
            this.defaultLoadCachedPromise = undefined;
            return providerConstructor;
        })());
        this.defaultLoadCachedPromise = loadPromise;
        return this.defaultLoadCachedPromise;
    }
    /**
     * Creates an instance of the last registered provider.
     * @param noWarn Set to true to disable warning log about multiple registered providers.
     */
    static async createProvider(noWarn = false) {
        if (this.availableProviders.length === 0) {
            const defaultProvider = await this.tryLoadDefaultBinProvider();
            if (defaultProvider === false) {
                throw new Error("No provider is registered. Install the `@blockstack/clarity-native-bin` peer " +
                    "dependency or register a provider manually with `registerProvider()`.");
            }
            else {
                this.availableProviders.push(defaultProvider);
            }
        }
        if (!noWarn && this.availableProviders.length > 1) {
            console.warn("Multiple providers are registered. The last registered provider will be returned.");
        }
        // Return the last registered provider
        const providerConstructor = this.availableProviders[this.availableProviders.length - 1];
        return providerConstructor.create();
    }
}
exports.ProviderRegistry = ProviderRegistry;
ProviderRegistry.availableProviders = [];
//# sourceMappingURL=registry.js.map