"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Type guard for objects that define `ResultInterface`.
 * If `success` is true then the `result` property is marked as defined,
 * otherwise, the `error` property is marked as defined.
 */
function matchResult(input, ok, error) {
    const extracted = extractResult(input);
    if (extracted.success) {
        return ok(extracted.result);
    }
    else {
        return error(extracted.error);
    }
}
exports.matchResult = matchResult;
/**
 * Type guard for objects that define `ResultInterface`.
 * If `success` is true then the `result` property is marked as defined,
 * otherwise, the `error` property is marked as defined.
 */
function extractResult(input) {
    if (input.success) {
        return { success: true, result: input.result };
    }
    else {
        return { success: false, error: input.error };
    }
}
exports.extractResult = extractResult;
/**
 * Unwraps an object that defines `ResultInterface`.
 * If `success` is true then the object's `result` value is returned.
 * Otherwise, an error is thrown with the given object's `error` value.
 * The type of the `error` value determines what gets thrown:
 * * If `error` is an instance of an `Error` object then it is directly thrown.
 * * If `error` is a string then an `Error` will be constructed with the string and thrown.
 * * If `error` is of neither type then the object is thrown directly (not generally recommended).
 */
function unwrapResult(input) {
    if (!input.success) {
        if (input.error) {
            if (input.error instanceof Error) {
                throw input.error;
            }
            else if (typeof input.error === "string") {
                throw new Error(input.error);
            }
            else {
                throw input.error;
            }
        }
        else {
            throw new Error("Result not successful and did not include an error message.");
        }
    }
    return input.result;
}
exports.unwrapResult = unwrapResult;
const getWrappedResult = (input, r) => {
    if (input.result) {
        const match = r.exec(input.result);
        if (!match) {
            throw new Error(`Unable to unwrap result: ${input.result}`);
        }
        return match[1];
    }
    throw new Error(`Unable to unwrap result: ${input}`);
};
function unwrapUInt(input) {
    const match = getWrappedResult(input, /^\(ok\su(\d+)\)$/);
    return parseInt(match);
}
exports.unwrapUInt = unwrapUInt;
function unwrapInt(input) {
    const match = getWrappedResult(input, /^\(ok\s(\d+)\)$/);
    return parseInt(match);
}
exports.unwrapInt = unwrapInt;
function unwrapString(input) {
    const match = getWrappedResult(input, /^\(ok\s0x(\w+)\)$/);
    return Buffer.from(match, "hex").toString();
}
exports.unwrapString = unwrapString;
exports.Result = {
    unwrap: unwrapResult,
    extract: extractResult,
    match: matchResult,
    unwrapUInt,
    unwrapInt,
    unwrapString,
};
//# sourceMappingURL=result.js.map