"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const child_process_1 = require("child_process");
const streamUtil_1 = require("./streamUtil");
async function executeCommand(command, args, opts) {
    const spawnOpts = {};
    if (opts) {
        if (opts.cwd) {
            spawnOpts.cwd = opts.cwd;
        }
        if (opts.env) {
            spawnOpts.env = opts.env;
        }
    }
    const proc = child_process_1.spawn(command, args, spawnOpts);
    const readStdout = streamUtil_1.readStream(proc.stdout, true, opts && opts.monitorStdoutCallback);
    const readStderr = streamUtil_1.readStream(proc.stderr, true, opts && opts.monitorStderrCallback);
    let writeStdin = Promise.resolve();
    if (opts && opts.stdin) {
        if (typeof opts.stdin === "string") {
            proc.stdin.end(opts.stdin, "utf8");
        }
        else {
            writeStdin = streamUtil_1.pipelineAsync(opts.stdin, proc.stdin).catch((error) => {
                console.error(`spawn stdin error: ${error}`);
            });
        }
    }
    proc.on("error", (error) => {
        console.error(`Unexpected process exec error: ${error}`);
    });
    const exitCode = await new Promise(resolve => {
        proc.once("close", (code) => {
            resolve(code);
        });
    });
    const [stdoutData, stderrData] = await Promise.all([readStdout, readStderr, writeStdin]);
    const stdoutStr = stdoutData.toString("utf8");
    const stderrStr = stderrData.toString("utf8");
    return {
        stdout: stdoutStr,
        stderr: stderrStr,
        exitCode: exitCode
    };
}
exports.executeCommand = executeCommand;
//# sourceMappingURL=execUtil.js.map