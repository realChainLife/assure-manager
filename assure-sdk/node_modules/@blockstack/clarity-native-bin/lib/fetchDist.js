"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = __importStar(require("fs-extra"));
const node_fetch_1 = __importDefault(require("node-fetch"));
const os = __importStar(require("os"));
const path = __importStar(require("path"));
const tar = __importStar(require("tar"));
const detectArch_1 = require("./detectArch");
const detectLibc_1 = require("./detectLibc");
const fsUtil_1 = require("./fsUtil");
const streamUtil_1 = require("./streamUtil");
const DIST_DOWNLOAD_URL_TEMPLATE = "https://github.com/blockstack/clarity-js-sdk/releases/" +
    "download/{tag}/clarity-cli-{platform}-{arch}.tar.gz";
/**
 * Checks if the currently executing platform and architecture has an distributable available
 * for download.
 * @param logger Optionally log error message for unsupported platform or arch.
 */
function isDistAvailable(logger) {
    let arch;
    const detectedArch = detectArch_1.detectArch(logger);
    switch (detectedArch) {
        case "x64":
            arch = "x64" /* x64 */;
            break;
        default:
            if (logger) {
                logger.error(`System arch "${detectedArch}" not supported. Must build from source.`);
            }
            return false;
    }
    let platform;
    switch (os.platform()) {
        case "win32":
        case "cygwin":
            platform = "win" /* WINDOWS */;
            break;
        case "darwin":
            platform = "mac" /* MACOS */;
            break;
        case "linux":
            if (detectLibc_1.detectLibc().isNonGlibcLinux) {
                platform = "linux-musl" /* LINUX_MUSL */;
            }
            else {
                platform = "linux" /* LINUX */;
            }
            break;
        default:
            if (logger) {
                logger.error(`System platform "${os.platform()}" not supported. Must build from source.`);
            }
            return false;
    }
    return {
        platform,
        arch
    };
}
exports.isDistAvailable = isDistAvailable;
/**
 * Gets a download url for a dist archive containing a binary that
 * can run in the currently executing system OS and architecture.
 * Returns false if system is incompatible with known available distributables.
 */
function getDownloadUrl(logger, versionTag) {
    const distInfo = isDistAvailable(logger);
    if (!distInfo) {
        return false;
    }
    const downloadUrl = DIST_DOWNLOAD_URL_TEMPLATE.replace("{tag}", versionTag)
        .replace("{platform}", distInfo.platform)
        .replace("{arch}", distInfo.arch);
    return downloadUrl;
}
exports.getDownloadUrl = getDownloadUrl;
/**
 * Returns true if install was successful.
 * @param opts
 */
async function fetchDistributable(opts) {
    const downloadUrl = getDownloadUrl(opts.logger, opts.versionTag);
    if (!downloadUrl) {
        return false;
    }
    opts.logger.log(`Fetching ${downloadUrl}`);
    const httpResponse = await node_fetch_1.default(downloadUrl, { redirect: "follow" });
    if (!httpResponse.ok) {
        opts.logger.error(`Bad http response ${httpResponse.status} ${httpResponse.statusText}`);
        return false;
    }
    const tempExtractDir = fsUtil_1.makeUniqueTempDir();
    opts.logger.log(`Extracting to temp dir ${tempExtractDir}`);
    const tarStream = tar.extract({ cwd: tempExtractDir });
    await streamUtil_1.pipelineAsync(httpResponse.body, tarStream);
    const binFileName = fsUtil_1.getExecutableFileName("clarity-cli");
    const tempBinFilePath = path.join(tempExtractDir, binFileName);
    opts.logger.log(`Moving ${tempBinFilePath} to ${opts.outputFilePath}`);
    fs.moveSync(tempBinFilePath, opts.outputFilePath);
    fs.removeSync(tempExtractDir);
    return true;
}
exports.fetchDistributable = fetchDistributable;
//# sourceMappingURL=fetchDist.js.map