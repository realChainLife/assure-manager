"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = __importStar(require("fs-extra"));
const path = __importStar(require("path"));
const cargoBuild_1 = require("./cargoBuild");
const fetchDist_1 = require("./fetchDist");
const fsUtil_1 = require("./fsUtil");
const logger_1 = require("./logger");
/**
 * Should correspond to both a git tag on the blockstack-core repo and a
 * set of clarity-binary distributables uploaded to the cloud storage endpoint.
 */
exports.CORE_SDK_TAG = "clarity-sdk-v0.1.0";
exports.BLOCKSTACK_CORE_SOURCE_TAG_ENV_VAR = "BLOCKSTACK_CORE_SOURCE_TAG";
exports.BLOCKSTACK_CORE_SOURCE_BRANCH_ENV_VAR = "BLOCKSTACK_CORE_SOURCE_BRANCH";
exports.BLOCKSTACK_CORE_SOURCE_PATH_ENV_VAR = "BLOCKSTACK_CORE_SOURCE_PATH";
/**
 * A git tag or branch name can be specified as an env var.
 * See [[BLOCKSTACK_CORE_SOURCE_TAG_ENV_VAR]] and [[BLOCKSTACK_CORE_SOURCE_BRANCH_ENV_VAR]].
 * @returns If an environment var is specified then returns the tag/branch string value.
 * Otherwise returns false.
 */
function getOverriddenCoreSource() {
    for (const [key, val] of Object.entries(process.env)) {
        if (val === undefined) {
            continue;
        }
        const keyStr = key.toLocaleUpperCase();
        if (keyStr === exports.BLOCKSTACK_CORE_SOURCE_TAG_ENV_VAR) {
            return { specifier: "tag", value: val };
        }
        else if (keyStr === exports.BLOCKSTACK_CORE_SOURCE_BRANCH_ENV_VAR) {
            return { specifier: "branch", value: val };
        }
        else if (keyStr === exports.BLOCKSTACK_CORE_SOURCE_PATH_ENV_VAR) {
            return { specifier: "path", value: val };
        }
    }
    return false;
}
/**
 * Resolve the directory of the currently executing package
 * @see https://stackoverflow.com/a/49455609/794962
 */
function getThisPackageDir() {
    const packagePath = path.dirname(require.resolve("../package.json"));
    return packagePath;
}
/**
 * Returns the full file path of the native clarity-cli executable.
 * Throws an error if it does not exist.
 * @param checkExists [Default = true] If true then an error is thrown if the file does not exist.
 * @param versionTag Defaults to the current `CORE_SDK_TAG`.
 */
function getDefaultBinaryFilePath({ checkExists = true, versionTag } = {}) {
    if (!versionTag) {
        versionTag = exports.CORE_SDK_TAG;
    }
    const thisPkgDir = path.resolve(getThisPackageDir());
    const binFileName = fsUtil_1.getExecutableFileName("clarity-cli");
    const binFilePath = path.join(thisPkgDir, ".native-bin", versionTag, binFileName);
    if (checkExists && !fs.existsSync(binFilePath)) {
        throw new Error(`Native binary does not appear to be installed at ${binFilePath}`);
    }
    return binFilePath;
}
exports.getDefaultBinaryFilePath = getDefaultBinaryFilePath;
async function installDefaultPath() {
    const installPath = getDefaultBinaryFilePath({ checkExists: false });
    const logger = logger_1.ConsoleLogger;
    let versionTag = exports.CORE_SDK_TAG;
    let versionBranch;
    let fromSource = false;
    // Check if source git tag/branch was specified using env var
    const sourceOverride = getOverriddenCoreSource();
    if (sourceOverride !== false && sourceOverride.specifier !== "path") {
        logger.log(`Found git source env var ${sourceOverride.specifier}=${sourceOverride.value}`);
        fromSource = true;
        if (sourceOverride.specifier === "branch") {
            versionTag = undefined;
            versionBranch = sourceOverride.value;
        }
        else {
            versionTag = sourceOverride.value;
        }
    }
    if (!fromSource) {
        const distFileAvailable = fetchDist_1.getDownloadUrl(logger, exports.CORE_SDK_TAG);
        if (!distFileAvailable) {
            fromSource = true;
        }
    }
    const outputIsValid = fsUtil_1.verifyOutputFile(logger, true, installPath);
    if (!outputIsValid) {
        return false;
    }
    let success;
    if (fromSource) {
        success = await cargoBuild_1.cargoInstall({
            logger: logger,
            overwriteExisting: true,
            outputFilePath: installPath,
            gitBranch: versionBranch,
            gitTag: versionTag
        });
    }
    else if (sourceOverride && sourceOverride.specifier === "path") {
        success = fsUtil_1.moveFromPath({
            logger,
            outputFilePath: installPath,
            inputFilePAth: sourceOverride.value,
        });
    }
    else {
        success = await fetchDist_1.fetchDistributable({
            logger: logger,
            overwriteExisting: true,
            outputFilePath: installPath,
            versionTag: versionTag
        });
    }
    return success;
}
exports.installDefaultPath = installDefaultPath;
async function install(opts) {
    const outputIsValid = fsUtil_1.verifyOutputFile(opts.logger, opts.overwriteExisting, opts.outputFilePath);
    if (!outputIsValid) {
        return false;
    }
    if (opts.fromSource) {
        return cargoBuild_1.cargoInstall(Object.assign(Object.assign({}, opts), { gitTag: opts.versionTag }));
    }
    else {
        return fetchDist_1.fetchDistributable(opts);
    }
}
exports.install = install;
//# sourceMappingURL=index.js.map